SQL学習記録用
学習し、記述したコードを記述していきます。

select order_id, user_id, quantity 
from sample.sales

select order_id
from sample.sales

select order_id, user_id, quantity
from `sample.sales`
order by order_id asc

select user_id, order_id, quantity
from `sample.sales`
order by user_id asc, order_id desc

select *
from sample.products

select * except (cost)
from `sample.products`

select * except (products_id, cost)
from sample.products

select 100
, "東京"
, "2020-01-01"
from sample.sales

select order_id, revenue * 1.1
from sample.sales

select (quantity + 2) * 3
from sample.sales

select order_id
, revenue
, quantity
, revenue / quantity
from sample.sales 
order by quantity desc

select order_id
, revenue
, quantity
, revenue / quantity as unit_price
from sample.sales 
order by quantity desc

select order_id, revenue as uriage
from sample.sales

select *
from `sample.sales`
limit 5

select order_id, data_time
from `sample.sales`
order by data_time desc
limit 5

select order_id, data_time
from `sample.sales`
order by data_time desc
limit 5 offset 100

select *
from `sample.customer`
where gender = 2

select *
from `sample.customer`
where gender = 2
order by register_date desc
limit 5 

select *
from `sample.customer`
where gender = 2 and birthday >= "1999-01-01"

select * 
from `sample.sales`
where quantity >= 4 or revenue >= 5000

select *
from `sample.customer`
where (gender = 1 or prefecture = "東京") 
and birthday >= "2000-01-01"

select *
from `sample.customer`
where gender = 1 or (prefecture = "東京"
and birthday >= "2000-01-01")

select *
from `sample.sales`
where quantity in (2,4,6)

select *
from `sample.customer`
where prefecture in ("青森", "岐阜", "鹿児島")

select * from sample.customer
where prefecture not in ("東京", "大阪", "愛知")

select *
from `sample.customer`
where name like "木%"

select * 
from `sample.customer`
where name like "%__子"

select *
from `sample.customer`
where birthday between "1999-01-01" and "1999-12-31"

select *
from `sample.sales`
where is_proper is true

select *
from `sample.sales`
where is_proper is not true

select *
from sample.customer
where birthday >= "1999-01-01"

select *
from sample.customer
where birthday <= "1998-12-31"

select *
from sample.customer
where birthday is null

select *
from sample.customer
where register_data in not null

select *
from sample.customer
where birthday is null

select *
from sample.customer
where register_data in not null

select product_id, sum(qty) as sum_qty
from sample.small_table
group by product_id

select user_id, count(*) as orders
from sample.small_users
group by user_id

select user_id, count(product_id) as orders
from sample.small_users
group by user_id

select user_id, count(distinct) as orders
from sample.small_users
group by user_id

select user_id
, sum(qty) as sum_qty
, avg(qty) as avg_qty
, max(qty) as max_qty
, min(qty) as min_qty
from sample.small_users
group by user_id

select count(*) as count_row
, count(product) as count_product
, count(distinct) as count_unique_product
, sum(qty) as sum_qty
, avg(qty) as avg_qty
, max(qty) as max_qty
, min(qty) as min_qty
from sample.small_users

select prefecture, count(distinct user_id) as users
from sample.customer
where birthday <= "1999-12-31"
group by prefecture
order by 2 desc

select user_id, product_id, avg(revenue) as avg_revenue
from sample.sales
where is_proper is true and prosuct_id in (1,2)
group by user_id, product_id
order by avg_revenue desc
limit 5 

select product_id 
, stddev_pop(quantity) as stddev_qty
from sample.sales
where product_id in (2,3)
group by product_id

select prefecture
, count(distinct user_id) as users
from sample.customer
group by prefecture
order by 2 desc

select prefecture, count(distinct user_id) as users
from sample.customer
group by prefecture
having users >= 20
order by 2 desc

select prefecture, count(distinct usr_id) as users
from sample.customer
where gender = 2
group by prefecture
having users >= 20
order by 2 desc

select 
if (birthday >= "1989-01-01"
, "平成以降生まれ", "昭和以前生まれ") as era
, count(dustinct user_id) as users
from `sample.customer`
group by era

select 
if (prefecture = "東京"
or prefecture = "神奈川"
or prefecture = "埼玉"
or prefecture = "千葉", "一都三県", "一都三県以外")　as pref_group
, count(distinct user_id) as users
from sample.customer
group by pref_group

select 
if (birthday is null, "未登録", "登録済") as birthday_regist
, count(distinct user_id) as users
from `sample.customer`
group by birthday_regist

select 
case prefecture
when "東京" then "関東主要都市"
when "神奈川" then "関東主要都市"
when "大阪" then "関西主要都県"
when "兵庫" then "関西主要都県"
when "京都" then "関西主要都県"
else "その他"
end as prefecture_group
, count(distinct user_id) as users
from `sample.customer`
group by prefecture_group
order by 2 desc

select 
case"
when birthday >= "2000-01-01" then "2000年代生まれ"
when birthday >= "1990-01-01" then "1990年代生まれ"
when birthday >= "1980-01-01" then "1980年代生まれ"
else "1970年代以前生まれ"
end as era_group
, count(distinct user_id) as users
from `sample.customer`
group by era_group
order by 2 desc

select birthday, count(*) as users
from `sample.customer`
where birthday is not null
group by birthday
having > 1

select user_id, count(*) as pageviews
from `sample.web_log`
where media = "email" and user_id is not null
group by user_id
having pageviews >= 10

select prefecture, count(distinct user_id) as users
from sample.customer
where is_premium is true
group by prefecture
order by 2 desc
limit 1

select cid, max(session_count) - min(session_count) + 1 as number_of_visits
from `sample.web_log`
group by cid
order by number_of_visits desc
limit 3

select 
case 
when cost >= 0 and cost < 300 then "1.低価格　0-299"
when cost >= 300 and cost < 600 then "1.低価格　300-599"
when cost >= 600 and cost < 900 then "1.低価格　600-899"
when cost >= 900 and cost < 1200 then "1.低価格　900-1200"
end as cost_range
, count(distinct product_id) as items
from sample.produsts
group by cost_range
order by 1

select hanbai.product_id, product_name, qty
from sample.small_sales_1 as hanbai
inner join sample.small_master as master
on hanbai.product_id = master.product_id

select product_id, product_name, qty
from sample.small_sales_1
inner join sample.small_master
using (product_id)

select product_id, product_name, qty
from sample.small_sales_1
left outer join sample.small_master
using (product_id)

select * 
from sample.small_sales_1
full outer join sample.small_master
using (product_id)

select *
from sample.small_sales_2 as jisseki
inner join sample.small_target as mokuhyou
on jisseki.year_month = mokuhyou.mouth 
and jisseki.product_category = mokuhyou.category

select jisseki.year_month
, jisseki.product_catrgory
, jisseki.sales
, mokuhyou.target
, jisseki.sales / mokuhyou.target as achivement_rate
from sample.small_sales_2 as jisseki
join sample.small_target as mokuhyou
on jisseki.year_month = mokuhyou.year_month
and jisseki.product_category = mokuhyou.product_catrgory
order by year_month, product_category

select *
from sample.small_sales_3
join sample.small_s_master using (shop_id)
join sample.small_p_master using (product_id)

select p_master.product_name
, s_master.shop_name
, orders.sales
from sample.small_sales_3 as orders
join sample.small_s_master as s_master
on orders.shop_id = s_master.shop_id
join sample.small_p_master as p_master
on orders.product_id = p_master.

select orders.product_id
, area_name
, shops.shop_name
, orders.sales
from sample.small_sales_3 as orders
join sample.small_s_master as shops
on orders.shop_id = shops.shop_id
join sample.small_a_master as areas
on shops.shop_area_id = areas.shop_area_id

select p_master.product_name
, s_master.shop_name
, a_master.area_name
, orders.sales
from sample.small_sales_3 as orders
join sample.small_s_master as s_master
on orders.shop_id = s_master.shop_id
join samole.small_a_master as a_master
on s_master.shop_area_id = a_master.shop_area_id
join sample.small_p_master as p_master
on orders.product_id = p_master.product_id

select user_id, product_id, avg(revenue) as avg_revenue
from sample.sales
where is_proper is true and product_id in (1,2)
group by user_id, product_id
order by avg_revenue desc
limit 5

select user_id, count(distinct product) as orders
from sample.small_users
group by user_id

select product_id, product_name, qty
from sample.small_sales_1
left outer join sample.small_master
using (product_id)

select * from sample.small_sales_1
full outer join sample.small_master
using (product_id)

select hanbai.product_id, product_name, qty
from sample.small_sales1 as hanbai
inner join sample.small_master as master
on hanbai.product_id = master.product_id
・onではなく、usingで共通して持つフィールドの名前が同じであれば使える
・left,rightは先に読み込むテーブルを全て残し、後に読み込むテーブルは共通して持つフィールドの値が重なっているレコードのみを残す。
・fullは先に読み込む左、後に読み込む右のすべてのレコードを残すが、相手方のテーブルにないフィールドの値はnullになる。

select * from samole.small_sales_2 as jisseki
join sample.small_target as mokuhyou
on jisseki.year_month = mokuhyou.month and 
jisseki.product_category = mokuhyou.category

select jisseki.year_month
, jisseki.product_category
, jisseki.sales
, mokuhyou.target
, jisseki.sales / mokuhyou.target as achivement_rate
from sample.small_sales_2 as jisseki
join samole.small_target as mokuhyou
on jisseki.year_month = mokuhyou.month and 
jisseki.product_category = mokuhyou.category
order by year_month, product_category
・joinはinner joinの略　意味は同じ

select *
from sample.small_sales_3
join sample.small_s_master using (shop_id )
join sample.small_p_master using (product_id)

select orders.product_id 
, areas.area_name
, shops.shop_name
, orders.sales
from sample.small_sales_3 as orders
join sample.small_s_masrer as shops
on orders.shop_id = shops.shop_id
join sample.small_a_master as areas
on shops.shop_area_id = areas.shop_area_id

select self1.year as base_year
, self2.year as next_year
, self1.qty as base_qty
, self.2qty as next_qty
, self2.qty / self1.qty as growth_rate
from samole.small_year as self2
on self1.year = self2.year - 1

select self1.year as base_year
, self2.year as compare_year
, self1.qty as base_qty
, self2.qty as compare_qty
from sample.small_year as self1
cross join samole.small_year as self2
・左側テーブルのレコード１行１行に右側テーブルの全レコードを結合する→総当たりでの結合方法

select self1.year as base_year
, self2.year as compare_year
, self1.qty as base_qty
, self2.qty as compare_qty
from sample.small_year as self1
cross join samole.small_year as self2
where salf1.year = 2017
order by compare_year

select 
ifnull (registration_year, 2017) as reg_year
, sun(ltv) as sum_ltv
from samole.small_ltv
inner join samole.small_customers using (user_id)
group by reg_year
・ifnullはそのレコードがnullの場合に適用する値を任意で設定できる。
上記の場合はnullの場合2017年と仮定する。










